<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>智能优化算法(GA、PSO、SA)模块化+Python实现</title>
      <link href="/archives/d6e6b021.html"/>
      <url>/archives/d6e6b021.html</url>
      
        <content type="html"><![CDATA[<p><img src="../images/article_2_cover.jpeg" alt="cover"></p><h2 id="总概">总概</h2><blockquote><p>此篇文章基于当初大二时数学建模实验课程的智能算法研究所作。废话不多说，直接follow。</p></blockquote><h2 id="三大智能优化算法本质探究">三大智能优化算法本质探究</h2><blockquote><p>不要被智能蒙蔽了双眼，本质其实就是利用一定规则进行局部搜索。<br>我们之前的传统算法基本是遍历穷举进行可行范围内寻求目标函数的最优解。但在这里有如下几个基本思维步骤（不涉及具体实现）。<br>1.全局可行解随机选取<br>2.可行解带入目标函数求值<br>3.值筛选，选取当前最优值<br>4.在当前最优值对应解进行有目标随机浮动，实现有目标随机遍历<br>5.2，3，4步骤进行重复<br>我觉得这些步骤看起来很简单，了解了这些基本步骤后对智能算法的原理以及实现也就更加清楚了。各种算法的差异主要体现在可行解的收敛算法。</p></blockquote><h2 id="遗传算法-ga">遗传算法(ga)</h2><blockquote><p>遗传算法有个特殊的地方，就是自变量编码问题。我们习惯性将对应维度的值转化成二进制编码然后串联组成DNA序列，然后具体计算再涉及编码解码的问题（其实本人觉得有点多此一举了）。<br>这里需要将可行解理解为DNA表现型。值筛选就按<b>适应度</b>（与目标函数有关）计算。值得关注的就是可行解的收敛算法了。<br>ga运用了我们大自然优胜劣汰（就是寻当前最优解），然后逐步扩大当前最优解的涉及影响范围（就是使尽量多的后代与其保持相同的DNA序列）。但这有个通病，就是容易导致可行解逐渐陷入局部最优解，而不是找到我们最需要的解（可以理解<b>局部最优就是陷入极小值点，而全局最优是最小值点</b>&gt;，高中数学就告诉我们这两者不一样。当然这是为了方便理解，对于离散非连续的函数可不能这么理解）。<br>为了解决这个问题，我们就利用变异，染色体交叉的操作来实现可行解跳出舒适圈（实现寻找其他最优解）。提高了遗传算法的感受野，更为容易寻找到目标函数的最优解。</p></blockquote><h2 id="粒子群算法-PSO">粒子群算法(PSO)</h2><blockquote><p>粒子群算法个人觉得就可行解的收敛算法与ga不一致罢了。但其更符合我们的社会行为。<br>粒子群随机分布，会互相联系，告知对方自己寻找到的最优解(群最优解)，以及心知肚明自己碰到的最优解，这些会影响自己的加速度(梯度)。然后每次迭代会改变自己的速度以及位置(高中物理就告诉我们速度是多维的，速度会改变多个维度变量的数值)，最终迭代结束，得到最优解。<br>该算法可以通过绘制粒子pos图(可通过PAC将变量加权降维到三维进行绘制)得出收敛的结论(前提是该目标函数可收敛，现象是粒子群逐渐汇聚，但偶尔有几个跑去其他地方寻找最优解了)</p></blockquote><h2 id="模拟退火算法-SA">模拟退火算法(SA)</h2><blockquote><p>该算法用处最多，尤其在电力系统中得到广泛应用。基于物理现象进行的算法设计。<br>首先温度很高，增加自变量的感受野(刚开始算法不会收敛)，随后逐步迭代温度降低，对非最优解的容忍度降低，逐步进入收敛过程。</p></blockquote><h2 id="本文不具体介绍各个算法原理，只是对于收敛算法的探究">本文不具体介绍各个算法原理，只是对于收敛算法的探究</h2><h2 id="Python代码实现">Python代码实现</h2><blockquote><p>首先给出目标函数如下:<br>$$<br>F(x)=\sum_ {i=1}^n (x_i^2-10cos(2\pi x_i)+10)<br>$$<br>其中n=30(也就是30个维度)。各个变量的边界条件为[-5.12,5.12]</p></blockquote><h3 id="ga实现">ga实现</h3><pre><code class="language-python">import numpy as npimport matplotlib.pyplot as pltdef decode(x, a, b):    &quot;&quot;&quot;解码，即基因型到表现型&quot;&quot;&quot;    xt = 0    for i in range(len(x)):        xt = xt + x[i] * np.power(2, i)    return a + xt * (b - a) / (np.power(2, len(x)) - 1)def decode_X(X: np.array,lb,ub,dna_num):    &quot;&quot;&quot;对整个种群的基因解码，上面的decode是对某个染色体的某个变量进行解码&quot;&quot;&quot;    X2 = np.zeros((X.shape[0],dna_num))    for i in range(X.shape[0]):        x=[]        for j in range(dna_num):            m=decode(X[i,10*j:10*(j+1)],lb,ub)#进行解码        x.append(m)        X2[i, :] = np.array(x)    return X2def select(X, fitness):    &quot;&quot;&quot;根据轮盘赌法选择优秀个体&quot;&quot;&quot;    fitness = 1 / fitness  # fitness越小表示越优秀，被选中的概率越大，做 1/fitness 处理    fitness = fitness / fitness.sum()  # 归一化        idx = np.array(list(range(X.shape[0])))    X2_idx = np.random.choice(idx, size=X.shape[0], p=fitness)  # 根据概率选择    X2 = X[X2_idx, :]    return X2def crossover(X, c):    &quot;&quot;&quot;按顺序选择2个个体以概率c进行交叉操作&quot;&quot;&quot;    for i in range(0, X.shape[0], 2):        xa = X[i, :]        xb = X[i + 1, :]        for j in range(X.shape[1]):            # 产生0-1区间的均匀分布随机数，判断是否需要进行交叉替换            if np.random.rand() &lt;= c:                xa[j], xb[j] = xb[j], xa[j]        X[i, :] = xa        X[i + 1, :] = xb    return X    def mutation(X, m):    &quot;&quot;&quot;变异操作&quot;&quot;&quot;    for i in range(X.shape[0]):        for j in range(X.shape[1]):            if np.random.rand() &lt;= m:                X[i, j] = (X[i, j] + 1) % 2    return Xdef fitness_func1(X):    return (X**2-10*np.cos(2*np.pi*X)+10).sum(axis=1)   def ga(fun_c,c,m,lb,ub,num,dna_num,iter_num):    &quot;&quot;&quot;遗传算法主函数&quot;&quot;&quot;    #fun_c:传入的优化函数（传入参数应该为矩阵）    #c:交叉概率    #m：变异概率    #num:种群数量    #dna_num:dna的数量（表现型）,也就是变量个数    #lb,ub:变量的上下边界（为矩阵的形式）    best_fitness = []  # 记录每次迭代的效果    best_xlist = []    X0 = np.random.randint(0, 2, (num, 10*dna_num))  # 随机初始化种群，为50*500的0-1矩阵    for i in range(iter_num):        X1 = decode_X(X0,lb,ub,dna_num)  # 染色体解码        fitness = fun_c(X1)  # 计算个体适应度        X2 = select(X0, fitness)  # 选择操作        X3 = crossover(X2, c)  # 交叉操作        X4 = mutation(X3, m)  # 变异操作        # 计算一轮迭代的效果        X5 = decode_X(X4,lb,ub,dna_num)        fitness = fun_c(X5)        best_fitness.append(fitness.min())        x= X5[fitness.argmin()]        best_xlist.append(x)        X0 = X4    # 多次迭代后的最终效果    print(&quot;最优值是：%.5f&quot; % best_fitness[-1])    print(&quot;最优解是：&quot;,best_xlist[-1])    plt.plot(best_fitness, color='r')    plt.show()ga(fitness_func1,0.1,0.1,-5.12,5.12,50,30,1000)</code></pre><p>得到如下结果:</p><img src="..\images\article_2_ga.png" style="zoom:100%;" /><h3 id="PSO实现">PSO实现</h3><pre><code class="language-python">import numpy as npimport matplotlib.pyplot as pltdef fit_fun(X):  # 适应函数(根据自身情况进行修改)    return (X**2-10*np.cos(2*np.pi*X)+10).sum(axis=1)class Particle:    # 初始化    def __init__(self, x_max, max_vel, dim):        self.__pos = np.random.uniform(-x_max, x_max, (1, dim))  # 粒子的位置        self.__vel = np.random.uniform(-max_vel, max_vel, (1, dim))  # 粒子的速度        self.__bestPos = np.random.random((1, dim))  # 粒子最好的位置        self.__fitnessValue = fit_fun(self.__pos)  # 适应度函数值    def set_pos(self, value):        self.__pos = value    def get_pos(self):        return self.__pos    def set_best_pos(self, value):        self.__bestPos = value    def get_best_pos(self):        return self.__bestPos    def set_vel(self, value):        self.__vel = value    def get_vel(self):        return self.__vel    def set_fitness_value(self, value):        self.__fitnessValue = value    def get_fitness_value(self):        return self.__fitnessValueclass PSO:    def __init__(self, dim, size, iter_num, x_max, max_vel, tol,  C1, C2, W,best_fitness_value=float('Inf')):        self.C1 = C1        self.C2 = C2        self.W = W              self.dim = dim  # 粒子的维度        self.size = size  # 粒子个数        self.iter_num = iter_num  # 迭代次数        self.x_max = x_max        self.max_vel = max_vel  # 粒子最大速度        self.tol = tol  # 截至条件        self.best_fitness_value = best_fitness_value        self.best_position = np.zeros((1, dim))  # 种群最优位置        self.fitness_val_list = []  # 每次迭代最优适应值        # 对种群进行初始化        self.Particle_list = [Particle(self.x_max, self.max_vel, self.dim) for i in range(self.size)]    def set_bestFitnessValue(self, value):        self.best_fitness_value = value    def get_bestFitnessValue(self):        return self.best_fitness_value    def set_bestPosition(self, value):        self.best_position = value    def get_bestPosition(self):        return self.best_position    # 更新速度    def update_vel(self, part):        vel_value = self.W * part.get_vel() + self.C1 * np.random.uniform(-1,1) * (part.get_best_pos() - part.get_pos()) \                    + self.C2 * np.random.uniform(-1,1) * (self.get_bestPosition() - part.get_pos())        vel_value[vel_value &gt; self.max_vel] = self.max_vel        vel_value[vel_value &lt; -self.max_vel] = -self.max_vel        part.set_vel(vel_value)    # 更新位置    def update_pos(self, part):        pos_value = part.get_pos() + part.get_vel()        pos_value[pos_value&gt;self.x_max]=self.x_max        pos_value[pos_value&lt;-self.x_max]=-self.x_max        part.set_pos(pos_value)        value = fit_fun(part.get_pos())        if value &lt; part.get_fitness_value():            part.set_fitness_value(value)            part.set_best_pos(pos_value)        if value &lt; self.get_bestFitnessValue():            self.set_bestFitnessValue(value)            self.set_bestPosition(pos_value)    def update_ndim(self):        for i in range(self.iter_num):            for part in self.Particle_list:                self.update_vel(part)  # 更新速度                self.update_pos(part)  # 更新位置            self.fitness_val_list.append(self.get_bestFitnessValue())  # 每次迭代完把当前的最优适应度存到列表            if self.get_bestFitnessValue() &lt; self.tol:                break        return self.fitness_val_list, self.get_bestPosition()if __name__ == '__main__':    pso = PSO(30, 20, 100000, 5.12, 1, 1e-12, 2, 5,8)    fit_var_list, best_pos = pso.update_ndim()    print(&quot;最优位置:&quot; + str(best_pos))    print(&quot;最优解:&quot; + str(min(fit_var_list)))    plt.plot(range(len(fit_var_list)), fit_var_list, alpha=0.5)    plt.show()</code></pre><p>得到如下结果:</p><img src="..\images\article_2_pso.png" style="zoom:100%;" /><h3 id="SA实现">SA实现</h3><pre><code class="language-python">import mathimport numpy as npfrom random import randomfrom numpy.random import randimport matplotlib.pyplot as pltdef func(X):                  #函数优化问题    X=np.array(X)    return (X**2-10*np.cos(2*np.pi*X)+10).sum()class SA:    def __init__(self, func,lb,ub,iter,dim, T0, Tf, alpha):        self.func = func         #定义优化函数        self.iter = iter         #内循环迭代次数        self.alpha = alpha       #降温系数        self.T0 = T0             #初始温度T0        self.Tf = Tf             #温度终值Tf        self.T = T0              #当前温度(这里只是初始化)        self.ub=ub               #自变量最大值        self.lb=lb               #自变量最小值        self.dim=dim             #自变量维数（也就是数量)        self.X =np.array([lb+(ub-lb)*rand()  for i in range(dim)                ])#限定取值区间        self.most_best =[]        self.history = &#123;'f': [], 'T': []&#125;    def generate_new(self, X):   #扰动产生新解的过程            X=np.array(X)            X_new=X+self.T*np.random.uniform(-1,1,X.shape)/100            X_new[X_new&lt;self.lb]=self.lb            X_new[X_new&gt;self.ub]=self.ub            return X_new     def Metrospolis(self, f, f_new):   #Metropolis准则        if f_new&lt;= f:            return 1        else:            p = math.exp((f - f_new) / self.T)            if random() &lt; p:                return 1            else:                return 0    def best(self):    #获取最优目标函数值        f = self.func(self.X)        return f   #f_best,idx分别为在该温度下，迭代L次之后目标函数的最优解和最优解的下标    def run(self):        count = 0        #外循环迭代，当前温度小于终止温度的阈值        while self.T &gt; self.Tf:                   for i in range(self.iter):                 f = self.func(self.X)                    #f为迭代一次后的值                X_new = self.generate_new(self.X) #产生新解                f_new = self.func(X_new)                        #产生新值                if self.Metrospolis(f, f_new):                         #判断是否接受新值                    self.X=X_new            # 迭代L次记录在该温度下最优解            ft = self.best()            self.history['f'].append(ft)            self.history['T'].append(self.T)            #温度按照一定的比例下降（冷却）            self.T = self.T * self.alpha                    count += 1                        # 得到最优解        f_best = self.best()        print(f&quot;F=&#123;f_best&#125;, x=&#123;self.X&#125;&quot;)sa = SA(func,-5.12,5.12,1000,30,100,0.01,0.98)sa.run()plt.plot(sa.history['T'], sa.history['f'])plt.title('SA')plt.xlabel('T')plt.ylabel('f')plt.gca().invert_xaxis()plt.show()</code></pre><p>SA算法结果如下:</p><img src="..\images\article_2_sa.png" style="zoom:100%;" /><h2 id="算法注意事项">算法注意事项</h2><blockquote><p>1.首先我们需要注意对于变量范围的划分，我们首先需要均匀选点绘制出离散图然后选择一个有效区间(加速收敛)。<br>2.超参数一定要认真调试，智能算法主要就是参数问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构+算法(一)：递归与递推</title>
      <link href="/archives/63534.html"/>
      <url>/archives/63534.html</url>
      
        <content type="html"><![CDATA[<p><img src="../images/article_1_cover.png" alt="cover"></p><h2 id="概念">概念</h2><blockquote><p align="left"><b>递归</b>:函数存在本身调用自身的情况，这便是递归。递的意思就是将问题拆解成子问题进行求解，子问题再进一步求解，直到无法进一步细致。归的意思就是最小子问题的求解。递归解题通用解决思路：  </p><p align="left">1.一个问题可以分解成具有相同解决思路的子问题（本质就是能调用同一个函数dfs）   </p><p align="left">2.经过层层分解的子问题最后一定是有一个不能再分解的固定值的（即终止条件）。当具备以上条件时，我们即可在一定T复杂度下使用递归实现。 </p><p align="left"><b>递推</b>:通过一定的公式或者堆砌将我们的结果从底层开始进行递推。</p>  </blockquote><h2 id="例题">例题</h2><h3 id="Question-1">Question_1</h3><blockquote><p>递归实现指数型枚举(<a href="https://www.acwing.com/problem/content/94/">原题链接</a>)</p></blockquote><h3 id="Answer-1">Answer_1</h3><blockquote><p>对于该问题，我们每个数字都是选与不选两种情况，不妨将0视为低电平，1为高电平触发使用。<br>故我们可以利用二进制来表示每次的结果。<br>我们可以通过位运算来获取每次的值<br>代码如下:</p></blockquote><pre><code class="language-python">n=int(input())for i in range((1&lt;&lt;n)):    lst=[]    for k in range(n):        if i&gt;&gt;k &amp; 1:            #说明该位为1            lst.append(str(k+1))    if len(lst)==0:        print(' ')    else:        print(' '.join(lst))</code></pre><blockquote><p>这是我们对题目进行理解后得到的结果，但我们在考场上可能很难第一时间就想到这种简洁的方式(bushi)。我们可以联想到<b>递推</b>。通过逐个递推每个数字是否使用，直到达到最后一个数字system.out。<br>代码如下:</p></blockquote><pre><code class="language-python">n=int(input())st_list=[0 for i in range(n+1)]#存储每个数是否被利用def dfs(k):    #k:当前遍历的数字    if k&gt;n:        str_lst=[]        for i in range(1,n+1):            if st_list[i]:                str_lst.append(str(i))        print(' '.join(str_lst))        return     st_list[k]=1    dfs(k+1)#用k    st_list[k]=0#恢复现场    dfs(k+1)#不用kdfs(1)</code></pre><p>以上两种代码均可AC。</p><h3 id="Question-2">Question_2</h3><blockquote><p>递归实现排列型枚举(<a href="https://www.acwing.com/problem/content/96/">原题链接</a>)</p></blockquote><h3 id="Answer-2">Answer_2</h3><blockquote><p>典型的萝卜填坑问题，我们利用st_lst来存储每个位置当前放置的数，同时judge_lst来存储每个数的利用情况(0代表未使用，1使用，模拟布尔值)。通过由小到大的顺序来进行dfs以满足字典序。<br>代码如下:</p></blockquote><pre><code class="language-python">n=int(input())st_lst=[0 for i in range(n+1)]#每个位置存储的数列表judge_lst=[0 for i in range(n+1)]def dfs(k):    if k&gt;n:        print(' '.join(list(map(str,st_lst[1:]))))        return     for i in range(1,n+1):        if judge_lst[i]==0:            st_lst[k]=i            judge_lst[i]=1            dfs(k+1)#下一层遍历            judge_lst[i]=0#恢复原状，不然全部都是existdfs(1)</code></pre><h3 id="Question-3">Question_3</h3><blockquote><p>费解的开关([原题链接][<a href="https://www.acwing.com/problem/content/97/">https://www.acwing.com/problem/content/97/</a>])</p></blockquote><h3 id="Answer-3">Answer_3</h3><blockquote><p>针对该问题，我们需要从题目特征中进行分析，开关两次就相当于没有任何效果，故我们对每个开关只需动一次or零次即可，而且当我们从上往下枚举时，每一个只会影响其上面的灯泡(因为后面的灯泡我们可以后考虑，无顺序性的好处)。最后只需要特判最后一行是否全亮即可(同时需要关注次数是否在六步之内)。于是这就是我们最典型的递推问题。<br>代码如下:</p></blockquote><pre><code class="language-python">from copy import deepcopyn=int(input())dx=[0,0,1,0,-1]dy=[0,-1,0,1,0]def change(x,y):    for i in range(5):        a=x+dx[i]        b=y+dy[i]        if a&gt;=0 and a&lt;5 and b&gt;=0 and b&lt;5:            mat_copy[a][b]^=1#取反操作for _ in range(n):    cnt=10    drag_mat=[list(map(int,list(input()))) for _ in range(5)]    #这里由于第一行的特殊情况，我们需要进行枚举，不然的话就不一定是最优解    #因为我们是从第二行开始操作的，故需要枚举第一行的操作。    for num in range(32):        #进行深复制，防止对原来的Mat造成影响        mat_copy=deepcopy(drag_mat)        ans=0        for k in range(5):            if (num&gt;&gt;k)&amp;1:                change(0,k)                ans+=1        for i in range(4):            for j in range(5):                if mat_copy[i][j]==0:                    change(i+1,j)                    ans+=1        #对最后一行进行特判        for j in range(5):            if mat_copy[4][j]==0:                ans=10        cnt=min(cnt,ans)    if cnt&gt;6:        cnt=-1    print(cnt)    try:        _=input()    except:        break</code></pre><h3 id="Question-4">Question_4</h3><blockquote><p>递归实现组合型枚举([原题链接][<a href="https://www.acwing.com/problem/content/95/">https://www.acwing.com/problem/content/95/</a>])</p></blockquote><h3 id="Answer-4">Answer_4</h3><blockquote><p>该题借鉴排列型枚举的思路，只不过我们的坑变少了而已。<br>代码如下:</p></blockquote><pre><code class="language-python">n,m=map(int,input().split())num=[]#引入动态数组存储结果def dfs(k):    if len(num)&gt;m or len(num)+(n-k+1)&lt;m:        #长度超过m或者剩余的数无法到达m，则采取剪枝，break即可        return     if k==n+1:        print(' '.join(list(map(str,num))))    num.append(k)#选择k    dfs(k+1)    #回溯    num.remove(k)    dfs(k+1)#不选择kdfs(1)#体会一下动态数组的强大!</code></pre><h3 id="Quesion-5">Quesion_5</h3><blockquote><p>带分数([原题链接][<a href="https://www.acwing.com/problem/content/1211/">https://www.acwing.com/problem/content/1211/</a>])</p></blockquote><h3 id="Answer-5">Answer_5</h3><blockquote><p>该题典型的全排列问题，我们可以首先进行全排列，随后进行a|b|c的分离模式进行判决等式是否成立。（但很明显该算法未实现剪枝操作，复杂度较高，无法AC）</p></blockquote><pre><code class="language-python">n=int(input())count=0exit_list=[0 for i in range(9)]num_list=[0 for i in range(9)]def calc(l,r):    res=0    for i in range(l,r+1):        res=res*10+num_list[i]    return resdef dfs(num):    global count    if num==9:        for i in range(7):            a=calc(0,i)            if a&gt;n:                continue            for j in range(i+1,8):                b=calc(i+1,j)                c=calc(j+1,8)                if (a*c+b==c*n):                    #转换成乘法（算法中常用的思想）                    count+=1        return     for i in range(9):        if not exit_list[i]:            exit_list[i]=1            num_list[num]=i+1            dfs(num+1)            exit_list[i]=0#回到初始状态dfs(0)print(count)</code></pre><blockquote><p>第二种解法：我们首先对于a进行排列型枚举，再对b进行，然后通过判决等式进行剪枝(c是否满足我们的条件:全选且不重复)。思路简单，但实操起来比较难理解(需要对栈的认知较高以及对python存储方式有所了解)。<br>代码如下:</p></blockquote><pre><code class="language-python">n=int(input())count=0exit_list=[0 for i in range(9)]num_list=[0 for i in range(9)]def calc(l,r):    res=0    for i in range(l,r+1):        res=res*10+num_list[i]    return resdef dfs(num):    global count    if num==9:        for i in range(7):            a=calc(0,i)            if a&gt;n:                continue            for j in range(i+1,8):                b=calc(i+1,j)                c=calc(j+1,8)                if (a*c+b==c*n):                    #转换成乘法（算法中常用的思想）                    count+=1        return     for i in range(9):        if not exit_list[i]:            exit_list[i]=1            num_list[num]=i+1            dfs(num+1)            exit_list[i]=0#回到初始状态dfs(0)print(count)</code></pre><h3 id="Question-6">Question_6</h3><blockquote><p>飞行员兄弟([原题链接][<a href="https://www.acwing.com/problem/content/118/">https://www.acwing.com/problem/content/118/</a>])</p></blockquote><h3 id="Answer-6">Answer_6</h3><blockquote><p>这题思路与费解的开关一致，并未变得更加复杂。但调试代码比较麻烦，不容易一次性写对。<br>代码如下:</p></blockquote><pre><code class="language-python">bridge_matrix=[]mat=[]count=10000num=0for i in range(4):    mat.append(list(input()))def change(i,j):    global bridge_matrix    for t in range(4):        bridge_matrix[i][t]='-'if bridge_matrix[i][t]=='+' else '+'        bridge_matrix[t][j]='-'if bridge_matrix[t][j]=='+' else '+'    bridge_matrix[i][j]='-'if bridge_matrix[i][j]=='+' else '+'def check():    for i in range(4):        for j in range(4):            if bridge_matrix[i][j]=='+':                return False    return Truedef dfs():    global bridge_matrix,count,num    for i in range(1,2**16):        #print(i)        bridge_matrix=mat.copy()        t=0        for j in range(15,-1,-1):            state=(i&gt;&gt;j)&amp;1            ind=(15-j)//4            col=(15-j)%4            if state:                change(ind,col)                t+=1        if check()and(t&lt;count):            num=i+1            count=t+1    print(count)    for j in range(15,-1,-1):        state=(num&gt;&gt;j)&amp;1        ind=(15-j)//4        col=(15-j)%4        if state:            print(str(ind+1)+' '+str(col+1))dfs()</code></pre><h3 id="Question-7">Question_7</h3><blockquote><p>翻硬币([原题链接][<a href="https://www.acwing.com/problem/content/1210/">https://www.acwing.com/problem/content/1210/</a>])</p></blockquote><h3 id="Answer-7">Answer_7</h3><blockquote><p>该题与费解的开关也很类似，而且更为简单。我们也可以利用递推来求解。做这种题就应该想到我们的操作顺序以及次数是否会对原有state有何影响。若满足操作顺序、偶数次数没影响时，阔以利用递推的思维来进行判断。<br>代码如下:</p></blockquote><pre><code class="language-python">str_init=list(input())str_target=list(input())count=0def turn(i):    global str_init    for t in range(i,i+2):        str_init[t]='*' if str_init[t]=='o' else 'o'def check(i):    if str_init[i]==str_target[i]:        return 0    return 1def dfs():    global count    for i in range(len(str_target)-1):        if check(i):            turn(i)            count+=1dfs()print(count)</code></pre><h2 id="总结">总结</h2><blockquote><p>我们可以得知，递推和递归的思想可以用来求解操作方式单一、问题可以逐步化解、操作顺序对结果无影响的问题。当然个人总结比较片面，仅供参考。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
